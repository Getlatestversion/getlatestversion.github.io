<!doctype html><html class=nojs lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Flaky builds – GetLatestVersion – Europe</title><meta name=description content="This post explores the topic of non-predictable builds and how to reach the goal of reproducible builds. There are huge benefits to reap in security, testability and …"><meta name=created content="2020-06-07T20:00:00+0100"><meta name=modified content="2020-06-07T20:00:00+0100"><meta name=contact content="info@getlatestversion.eu"><meta property="og:site_name" content="GetLatestVersion – Europe"><meta property="og:title" content="Flaky builds"><meta property="og:url" content="http://www.getlatestversion.eu/2020/06/flaky-builds/"><meta property="og:type" content="article"><meta name=generator content="Hugo 0.68.3"><meta name=msapplication-TileColor content="#ffffff"><meta name=theme-color content="#ffffff"><link rel=canonical href=http://www.getlatestversion.eu/2020/06/flaky-builds/><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel=stylesheet href=/css/mobile.2ab74aa64785dcab8114959e76ca140cf76207cd85989bc6d4fc3b12f734a09e.css media=screen><link rel=stylesheet href=/css/styles.07de9722ae74190da91740ecb1e12bbfa31de324e29ab4972bdcc4131519528c.css><link rel=stylesheet href=/css/print.27fc184f8670f41a2690985390779e7b20335a8fadff8fa015cf9417ffe50c36.css media=print><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Flaky builds","datePublished":"2020-06-07T20:00:00+01:00","dateModified":"2020-06-07T20:00:00+01:00","url":"http://www.getlatestversion.eu/2020/06/flaky-builds/","description":"This post explores the topic of non-predictable builds and how to reach the goal of reproducible builds. There are huge benefits to reap in security, testability and …","keywords":["build","top 10 mistakes","reproducible builds","flaky tests","dependencies"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://www.getlatestversion.eu/"},"publisher":{"@type":"Organization","name":"GetLatestVersion – Europe","url":"http://www.getlatestversion.eu/"}}</script><script defer src=/js/lib/umbrella.min.b426107371d121c9a56a27aac9e9058ff592a021e2f4c3c94827fe70920d3cbb.js></script><script defer src=/js/mobile.min.3a3510028bab9810834389725137cfa50f5d3231799ef9ac70769331fa59859a.js></script><script defer src=/js/script.min.8e4d91ebe0d9226621e408b7205bd7b009e4935608e4b29c4275116490cc836d.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-165859091-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script src=https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js></script><script src=http://www.getlatestversion.eu/js/jquery-eu-cookie-law-popup.js></script><link rel=stylesheet href=http://www.getlatestversion.eu/css/jquery-eu-cookie-law-popup.css><script>$(document).ready(function(){$(document).euCookieLawPopup().init({cookiePolicyUrl:'/page/privacy/',popupPosition:'top',colorStyle:'default',compactStyle:false,popupTitle:'This website is using cookies',popupText:'By continuing I assume your permission to deploy cookies, as detailed in the Privacy &amp; Cookies Policy.',buttonContinueTitle:'Continue',buttonLearnmoreTitle:'Learn more about this site Privacy &amp; Cookies Policy',buttonLearnmoreOpenInNewWindow:true,agreementExpiresInDays:30,autoAcceptCookiePolicy:false,htmlMarkup:null});});</script></head><body class=single-page><div class="page layout__page layout__sidebar-second"><header class="header layout__header"><a href=/ title=Home rel=home class=header__logo><img src=/images/logo.png alt=Home class=header__logo-image></a><h1 class=header__site-name><a href=/ title=Home class=header__site-link rel=home><span>GetLatestVersion – Europe</span></a></h1><div class="region header__region"><h2 class=visually-hidden>Language selector</h2><nav class="language-selector layout__language-selector"><ul class=navbar><li><a rel=alternate href=/it hreflang=it lang=it>Italiano</a></li></ul></nav></div></header><nav class="main-menu layout__navigation"><h2 class=visually-hidden>Main menu</h2><ul class=navbar><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li><li><a href=/authors/>Authors</a></li><li><a href=/about/>About</a></li></ul></nav><main class="main layout__main"><article class="section-post single-view"><header><h1 class="title title-submitted">Flaky builds</h1><div class=submitted><a href=/authors/giuliov><span class=author itemprop=author>Giulio Vian</span></a>
- <time class=created-date datetime=2020-06-07T20:00:00+01:00>7 June, 2020</time></div><div class=tags>Tags:<ul><li><a href=/tags/build>build</a></li><li><a href=/tags/top-10-mistakes>top 10 mistakes</a></li><li><a href=/tags/reproducible-builds>reproducible builds</a></li><li><a href=/tags/flaky-tests>flaky tests</a></li><li><a href=/tags/dependencies>dependencies</a></li></ul></div></header><div class=content><p>The topic is huge and I do not have the room to go through all the details in one post, so I stick to a cursory view. I will sprinkle references to additional material so you can deep dive later.</p><h2 id=what-is-a-flaky-build>What is a &lsquo;flaky&rsquo; build?</h2><p>A &lsquo;flaky&rsquo; build is a build whose outcome is, in some ways, unpredictable. This is generally bad because you expect your CI to be algorithmic, deterministic, with no randomness. The worse consequence of an unpredictable build lies in the future: that day when you run the same build, maybe in the hurry of delivering a patch, and it fails unexpectedly. Some may think that is is just another piece of evidence for Murphy’s Law<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, which applies to all time and space.
The unpredictability may be subtle; for example, the build always succeeds but its results are never quite the same.
In the following, I will review the most common flakiness scenarios.</p><h2 id=same-source-different-binaries>Same source, different binaries</h2><p>Have you tried comparing binaries built on two different machines? More often than not, they will be different! Even if you use the exact same source code version. Worse, even on the same machine, rebuilding the same code at a later time will produce different binaries.</p><p>My first example is a .NET 4.x assembly: the next picture shows the binary difference between files built from the same sources a few minutes apart.
<img src=dotnet4.8-hexdiff.png alt="Binary diff of Exes">
Traditionally Microsoft tools embedded some kind of build timestamp in binaries for a number of reason, especially to help Windows&rsquo; Loader<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>I obtained a similar result with Maven building a JAR package, I used Beyond Compare to compare more easily.
<img src=mvn-diff1.png alt="JAR content difference">
The difference is in the <code>pom.properties</code> manifest, which contains a time-stamp marking when the package was built.
<img src=mvn-diff2.png alt="Maven manifest difference"></p><p>There are ways to fix these behaviors and join the camp of repeatable builds, like myself.</p><h3 id=why-should-i-care>Why should I care?</h3><p>The ability to compare binaries helps or is even required in many circumstances:</p><ul><li>troubleshooting, you can quickly compare a binary file generated on your machine with another from unknown source;</li><li>deployment, you can skip copying/deploying binary identical files;</li><li>patching, generating binary patches is easier;</li><li>auditing, you can demonstrate the version of code that is running in production matches source code;</li><li>security, the binary hasn&rsquo;t been tampered by an attacker.</li></ul><p>Hope this convince you that these goals are worth your time and effort. Auditing and security are becoming of greater importance these days.</p><h3 id=reproducible-builds>Reproducible builds</h3><p>Let&rsquo;s state a clear goal, we want reproducible builds that generate identical <em>main</em> artifacts when using the same version of source code.
What do I mean with <em>main</em> artifacts? That we allow for ancillary artifacts to change at every run; a trivial example is a build log or release note file. We forbid differences in executable binaries, data or configuration files, scripts and tools.
With this definition, a release note file displaying a build id or timestamp is fine.</p><p>To achieve this goal, you have to look at the tools&rsquo; manuals. I will detail a few common scenarios.
In addition to the following suggestions, you have to consider a proper archival and versioning of the toolchain in use to build the software. A newer version of compiler, SDK, build may produce different results.</p><h3 id=net-reproducible-builds>.NET Reproducible builds</h3><p>The Roslyn C# compiler offers the <a href=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/deterministic-compiler-option><code>-deterministic</code></a> flag a few years now, that is, from Visual Studio 2015. You turn on the option setting the <code>Deterministic</code> MSBuild property to <code>true</code> in the project file.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml>  <span style=color:#f92672>&lt;PropertyGroup&gt;</span>
    <span style=color:#f92672>&lt;Deterministic&gt;</span>true<span style=color:#f92672>&lt;/Deterministic&gt;</span>
    <span style=color:#f92672>&lt;PathMap&gt;</span>$(MSBuildThisFileDirectory)=\src<span style=color:#f92672>&lt;/PathMap&gt;</span>
  <span style=color:#f92672>&lt;/PropertyGroup&gt;</span>
</code></pre></div><p>By the way, you do not need to rush editing you project files to set these properties. You can add a <code>Directory.Build.props</code> file<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> at the root of your project and the setting will be applied to all projects under the same directory.
I have a good news: .NET Core SDK projects use the <code>deterministic</code> flag by default. The bad news is that it is not enough in some cases, but keep on reading.</p><p>In the above example, you have surely noted another property, <code>PathMap</code>, which matches the <a href=https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/pathmap-compiler-option><code>-pathmap</code></a> compiler option. This option alters the paths embedded in executables and PDBs<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> and is especially useful when building on a server. Typically each agent on the server has a different base directory, and the generated files embed the agent specific path. With <code>PathMap</code> you define a conventional directory (<code>\src</code> in the example) independent from the effective directory used for the build.
A useful resource is Jared Parsons&rsquo; post <a href=https://blog.paranoidcoding.com/2016/04/05/deterministic-builds-in-roslyn.html><em>Deterministic builds in Roslyn</em></a>.</p><h3 id=maven-java-reproducible-builds>Maven (Java) Reproducible builds</h3><p>It is very easy to replace the timestamp in <code>pom.properties</code>, just add a <code>project.build.outputTimestamp</code> property</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml>  <span style=color:#f92672>&lt;properties&gt;</span>
    <span style=color:#f92672>&lt;project.build.outputTimestamp&gt;</span>2020-06-06T22:12:34Z<span style=color:#f92672>&lt;/project.build.outputTimestamp&gt;</span>
  <span style=color:#f92672>&lt;/properties&gt;</span>
</code></pre></div><p>to the <code>pom.xml</code> file. This requires that you use a recent version (3.2 or later) of Maven plugins. You can find all the details in <a href=https://maven.apache.org/guides/mini/guide-reproducible-builds.html><em>Configuring for Reproducible Builds</em></a>.</p><p>The <code>pom.properties</code> solves the simple issue but there are additional data, used during build, that can produce different outcomes. A more through approach use the <a href=https://zlika.github.io/reproducible-build-maven-plugin/>Reproducible Build Maven Plugin</a> which guarantees identical binaries given unchanged sources.</p><h3 id=other-languages>Other languages</h3><p>C/C++ developers can profitably study <a href=https://blog.conan.io/2019/09/02/Deterministic-builds-with-C-C++.html>An introduction to deterministic builds with C/C++</a>; this article explores the main issue on each major platform (Windows, Mac, and Linux).
I recommend the <a href=https://reproducible-builds.org/>https://reproducible-builds.org/</a> site for Linux and C/C++ information about Reproducible builds.
C/C++ reproducible can be complex to implement, caring for lots of detail, so I do not even dare to start in a short article like this one.</p><p>Go language has its quirks too. You may want to avoid the C compiler and linker, using the <code>CGO_ENABLED=0</code> setting, or embrace complexity. The other main issue is path strings embedded in binaries. The <a href=https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies><code>-trimpath</code></a> flag, available with Go 1.13 and later, resolves using a conventional path (similar to C# <code>-pathmap</code>).</p><h2 id=same-definition-different-set-of-files>Same definition, different set of files</h2><p>Dependencies are the next source of troubles for build predictability. I see this as a separate topic from reproducible builds because the focus is not the individual file you coded, but the general outcome and files outside your direct control.</p><p>The issue caused by dependencies is simple to describe. Your project depends on, at least one, external file. The first time you build, you get a version of this external file, say v1.0. The next time you build, the version for the external file is different: it can be v1.0.1, v1.1, v2.0 or else.</p><p>We can set apart four reasons for non-predictable outcomes when it comes to dependencies:</p><ul><li>Loose specification & newer packages versions available;</li><li>Newer versions available for indirect dependencies;</li><li>Loss of package source (direct or indirect);</li><li>Change in package manager and its algorithm.</li></ul><h3 id=loose-dependencies-specifications>Loose dependencies specifications</h3><p>Every modern library manager permits to specify a strict or a loose rule for a dependent file. The strict rule states a unique version for the library package. A loose rule defines a range of acceptable versions.
When the library author publishes a new version, what happens to your build depends on the rule. A strict rule will always retrieve the same version, a loose rule may force the package manager to download a different version. Let&rsquo;s see a practical example.</p><table><thead><tr><th align=center>Date</th><th align=center>Dependency Rule</th><th align=center>Available versions</th><th align=center>Version selected</th></tr></thead><tbody><tr><td align=center>1 Jan</td><td align=center>= 1.0</td><td align=center>1.0</td><td align=center>1.0</td></tr><tr><td align=center>1 Jan</td><td align=center>1.0&lt;= and &lt;2.0</td><td align=center>1.0</td><td align=center>1.0</td></tr><tr><td align=center>1 Feb</td><td align=center>= 1.0</td><td align=center>1.0, 1.1</td><td align=center>1.0</td></tr><tr><td align=center>1 Feb</td><td align=center>1.0&lt;= and &lt;2.0</td><td align=center>1.0, 1.1</td><td align=center>1.1</td></tr><tr><td align=center>1 Mar</td><td align=center>= 1.0</td><td align=center>1.0, 1.1, 1.2, 2.0</td><td align=center>1.0</td></tr><tr><td align=center>1 Mar</td><td align=center>1.0&lt;= and &lt;2.0</td><td align=center>1.0, 1.1, 1.2, 2.0</td><td align=center>1.2</td></tr><tr><td align=center>1 Apr</td><td align=center>= 1.0</td><td align=center>1.2, 2.0, 2.1</td><td align=center>error</td></tr><tr><td align=center>1 Apr</td><td align=center>1.0&lt;= and &lt;2.0</td><td align=center>1.2, 2.0, 2.1</td><td align=center>1.2</td></tr></tbody></table><p>In this example, after the author publishes a new minor version, the build (<em>rectius</em> the package manager) use the new minor version for the looser rule, while the strict rule stick to version 1.0.
You may have noticed the 7th line, the build using the strict rule fails because the required version of the package is no more available. This is not the scenario we will discuss in <a href=#lost-source><em>Lost source</em></a>, but the solution is the same.
Note that some package managers do not select the most recent version of a package (Maven is an example).</p><h3 id=indirect-dependencies>Indirect dependencies</h3><p>The <a href=#loose-dependencies-specifications>above</a> scenario is very simple because it analyses a direct dependency, i.e. the code you are building directly depends on the specified library version.
This is rarely the case in practice: the libraries you use depends on other libraries and so on. On average a project has a couple of hundred dependencies, direct or indirect <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</p><p>While you can set very strict rules for your direct dependencies, you have no control on indirect dependencies. Only the library author can define the rules for the latter.
Let&rsquo;s see a simple example.</p><p><img src=diamond-dependency-graph.png alt="Diamond dependency graph"></p><p>We say that <strong>Library C</strong> is a transitive dependency for App.
<strong>Library A</strong> requires at least version 2.0 of <strong>Library C</strong> while <strong>Library C</strong> requires a minimum 3.0 version. The package manager will pick version 3, which may have unexpected effects.</p><p>There is a solution to this and the previous issue and is generally referred as <em>locking</em>.</p><h3 id=fixing-loose-specifications-and-indirect-dependencies>Fixing loose specifications and indirect dependencies</h3><p>The most used library package managers offer a <em>locking</em> mechanism: the tool evaluates the whole dependency graph, determining the set of version that satisfy all dependency rules, save the result in a <em>lock</em> file, and use such result from now on without evaluating again. This mechanism is sometimes called <em>pinning</em> or <em>fixing</em> library versions, as you are taking a snapshot of dependency graph at a point in time.</p><p><strong>NuGet</strong> uses <a href=https://github.com/NuGet/Home/wiki/Enable-repeatable-package-restore-using-lock-file><code>packages.lock.json</code> file</a> to control locking. The presence of the file, even empty, triggers the mechanism. You can have this file at the project level (e.g. same directory as <code>.csproj</code> project file) or at the root of the Git repository, depending how you prefer managing dependencies.</p><p><strong>Maven</strong> requires that you use the <a href=http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management><code>&lt;dependencyManagement></code> stanza</a> to define the versions for direct and indirect dependencies. This mechanism is not 100% robust, so the community has devise some plugins to help manage the list and detect violations like <a href=https://github.com/vandmo/dependency-lock-maven-plugin>dependency-lock-maven-plugin</a>.</p><p><strong>Gradle</strong> offers a very sophisticated mechanism based on a set of <a href=https://docs.gradle.org/current/userguide/dependency_locking.html>lock files</a>. It is an opt-in mechanism that requires modification to the <code>build.gradle</code> script.</p><p><strong>npm</strong> uses <a href=https://docs.npmjs.com/configuring-npm/package-locks.html><code>package-lock.json</code></a> file.</p><p>Python has a few tools to solve this problem. Notable is <a href=https://github.com/pypa/pipenv>pipenv</a> which uses <code>Pipfile.lock</code>. In a build script, you use the <code>pipenv sync</code> command which uses the <code>Pipfile.lock</code> exclusively.</p><h3 id=lock-files-and-pipelines>Lock files and pipelines</h3><p>Once the lock file is generated, commit it to source control. This guarantees that others developers, and build pipelines use the same lock file as you.</p><p>Be aware that the content of lock files is not written on stone. If you change the main dependency file (<code>.csproj</code>, <code>packages.config</code>, <code>packages.json</code>, etc.), the library package manager updates the lock at the first run, unless you block this behaviour. In a build must <strong>always</strong> force the use of a lock file, that is:</p><ul><li>set MSBuild <code>RestoreLockedMode</code> property to <code>true</code>;</li><li>use <code>dotnet restore</code> command with the <code>--locked-mode</code> option;</li><li>use <code>npm ci</code> <strong>not</strong> <code>npm install</code>;</li><li>use <code>pipenv sync</code> <strong>not</strong> <code>pipenv install</code>;</li></ul><h3 id=lost-source>Lost source</h3><p>We still have one scenario depicted in the table: how to cope with library versions that are no more available.
If you think that it never happens, please read the <a href=https://www.theregister.com/2016/03/23/npm_left_pad_chaos/>story of left-pad</a>.</p><p>The solution is to add some kind of buffer between your build and the external world, a storage for input artifacts. There quite a number of products, generally labelled as <em>Artifact Store</em> or <em>Artifact Manager</em>: <a href=https://jfrog.com/artifactory/>Artifactory</a>, <a href=https://www.myget.org/>MyGet</a>, <a href=https://www.sonatype.com/product-nexus-repository>Nexus</a>, <a href=https://inedo.com/proget>ProGet</a>, <a href=https://docs.microsoft.com/en-us/azure/devops/artifacts>Azure Artifacts</a> and so on.</p><p>These products require some tweaks on the build configuration so that the library package manager asks the Artifact Manager before going to the original source. NuGet uses the <a href><code>NuGet.Config</code> file</a> at machine or user level to search for sources; npm leverages the <a href=https://docs.npmjs.com/misc/config#registry><code>registry</code></a> key in its configuration and so on.
The Artifact Manager returns the library package, if available locally, or goes to the original source and cache it locally.</p><p>Artifact Managers offer support to the most common library package formats (Maven, npm, NuGet, etc.) and a caching mechanism that shields you from a sudden disappearance of a library.</p><h3 id=tool-chain-issues>Tool chain issues</h3><p>The final piece is the library package manager tool itself. Matching algorithms, syntax, all might change on newer version. It is important to have copies of the executable, its configuration.
The golden rule is being able to recreate the exact build environment that was used at any point in the past. I discussed the value of Docker in details in <a href=http://blog.casavian.eu/2019/08/19/meta-pipelines-introduction/>this article</a>.</p><h2 id=same-tests-different-results>Same tests, different results</h2><p>Flaky tests are the third major cause of uncertainty in builds. Flaky tests randomly pass or fail despite the build being identical.</p><p>What kind of test can be so unpredictable? Tests that depends on external resources. For example, you deploy a web application and run a smoke test that checks if the site is up; if the web application host is slow to start, the remote call may time-out and the test fails. Unit tests, by definition, do not depends on external resources, so your focus should be on integration tests. Design integration tests for predictability; it is better that a whole suite of tests fails. e.g. by checking connectivity at entering the suite, than having a random test of the suite failing. Another scenario might be that tests have an implicit order, and the runner executes them in parallel, thus the random outcome.
Martin Fowler wrote a beautiful <a href=https://martinfowler.com/articles/nonDeterminism.html>essay on flaky tests</a> and I recommend studying it to gain a deep understanding why this happens and some preventions.</p><h3 id=how-to-harness>How to harness</h3><p>Practitioner have to face the reality of unforeseen problems. Luckily, modern build tools offer some relief.
You can automatically re-run failed tests and report which tests pass on the second (or more) attempt.</p><ul><li>in Azure DevOps you turn on this feature at the project level (<a href=https://docs.microsoft.com/en-us/azure/devops/pipelines/test/flaky-test-management>https://docs.microsoft.com/en-us/azure/devops/pipelines/test/flaky-test-management</a>);</li><li>Jenkins has a plugin named <a href=https://plugins.jenkins.io/flaky-test-handler/><em>Flaky Test Handler</em></a> somewhat limited;</li><li>GitLab suggests a <a href=https://about.gitlab.com/handbook/engineering/quality/guidelines/debugging-qa-test-failures/#flaky-test>sophisticated process</a> that accounts for a number of failure scenarios, allowing tagging tests so the build pipeline knows about flakiness or other issues.</li></ul><h2 id=in-summary>In summary</h2><p>We explored cursory the topic of non-predictable builds. The root of randomness may lie in the compiler, the linker, the library manager, the dependency manager, in the test suites.
There are options, tools and techniques that help in minimise or even completely get rid of variation and have fully reproducible builds.
You should aim at repeatable, even reproducible builds: they are a defense weapon for the developer in the modern world.
A final word for the tool-chain. If you need to go back and rebuild years old versions, you must archive the exact set of tools you use for building and keep it safe. A different version for a compiler or a library manager can have a big impact on your ability to reproduce an old version.</p><hr><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>&ldquo;Anything that can go wrong will go wrong&rdquo;. <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>Raymond Chen&rsquo;s post <a href="https://devblogs.microsoft.com/oldnewthing/20100318-00/?p=14563">What is DLL import binding?</a> and also <a href="https://devblogs.microsoft.com/oldnewthing/20180103-00/?p=97705">Why are the module timestamps in Windows 10 so nonsensical?</a>. <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p>MSBuild documentation <a href=https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build>Customize your build</a>. <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4 role=doc-endnote><p>Program database (PDB) is Microsoft&rsquo;s file format for storing debugging information. <a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5 role=doc-endnote><p>Source <a href=https://octoverse.github.com/#dependencies-overview>GitHub</a>: &ldquo;<em>203 package dependencies, on average, support every public and private repository with an enabled dependency graph</em>&rdquo; <a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"www-getlatestversion-eu"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></article></main><aside class="sidebar layout__second-sidebar"><section><h4 class=menu><a href=/post/ class=active aria-current=page>Posts</a></h4><ul class=menu><li><a href=/2020/08/migrating-work-items-from-jira-to-azure-devops/>Migrating work items from Jira to Azure DevOps</a></li><li><a href=/2020/06/flaky-builds/ class=active aria-current=page>Flaky builds</a></li><li><a href=/2020/05/top-10-pipeline-mistakes/>Top 10 Pipeline mistakes</a></li><li><a href=/2020/05/code-dependencies-binary-composition-is-not-only-a-mathematics-calculation/>Code dependencies: Binary Composition is not only a mathematics calculation</a></li><li><a href=/2020/05/reducing-the-gap-between-operations-and-development-using-azure-devops/>Reducing the gap between operations and development using Azure DevOps</a></li></ul></section><section><h4 class=menu><a href=/page/>Pages</a></h4><ul class=menu><li><a href=/page/privacy/>Privacy</a></li></ul></section></aside><footer class="footer layout__footer"><p>© 2020 GetLatestVersion</p><p>A <a href=http://www.getlatestversion.eu/>GetLatestVersion</a> production. <a href=/page/privacy>Privacy policy</a></p><p>Powered by <a href=https://gohugo.io/>Hugo</a> and the <a href=https://github.com/frjo/hugo-theme-zen>Zen theme</a>.</p></footer></div><div class=mobile-nav dir=ltr><div class=mobile-nav__cover></div><a href=#navigation class=mobile-nav__toggle aria-haspopup=true role=button>Menu</a><div class=mobile-nav__sheet><div class=mobile-nav__region><h2 class=visually-hidden>Language selector</h2><nav class="language-selector layout__language-selector"><ul class=navbar><li><a rel=alternate href=/it hreflang=it lang=it>Italiano</a></li></ul></nav></div><nav class=mobile-nav__main-menu><h2 class=visually-hidden>Main menu</h2><ul class=mobile-nav__navbar><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li><li><a href=/authors/>Authors</a></li><li><a href=/about/>About</a></li></ul></nav></div></div></body></html>