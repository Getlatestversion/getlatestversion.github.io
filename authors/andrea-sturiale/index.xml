<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Andrea Sturiale on GetLatestVersion – Europe</title><link>http://www.getlatestversion.eu/authors/andrea-sturiale/</link><description>Recent content in Andrea Sturiale on GetLatestVersion – Europe</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 03 Nov 2021 03:00:00 +0200</lastBuildDate><atom:link href="http://www.getlatestversion.eu/authors/andrea-sturiale/index.xml" rel="self" type="application/rss+xml"/><item><title>The limit is your own imagination, do it with Azure DevOps Services REST API</title><link>http://www.getlatestversion.eu/2021/11/the-limit-is-your-own-imagination-do-it-with-azure-devops-services-rest-api/</link><pubDate>Wed, 03 Nov 2021 03:00:00 +0200</pubDate><author>Bartolomeo Lombardi</author><author/><guid>http://www.getlatestversion.eu/2021/11/the-limit-is-your-own-imagination-do-it-with-azure-devops-services-rest-api/</guid><description>&lt;p>Azure DevOps is the platform signed by Microsoft that helps software factories to improve the development process, automatic tests and frequent releases. Their aim is to have additional value for the end customer in terms of product quality.&lt;/p>
&lt;p>With Azure DevOps Release you can separate the delivery environments into groups, obtaining integration, acceptance, production environments and so on. Most of time, the pipelines are configured to release the artifacts related to the main branches. However, Azure DevOps doesn&amp;rsquo;t allow to modify easily a specific release for a single target within a Deployment Group (DG) starting from different artifacts.&lt;/p>
&lt;h1 id="automated-through-the-azure-devops-services-rest-api">Automated through the Azure DevOps Services REST API&lt;/h1>
&lt;p>Consider a scenario in which we have a DG called &amp;ldquo;integration&amp;rdquo; that collects 20 virtual machines (VMs), one for each developer. Through this DG we can use a pipeline that deploys the latest version of the product to all the VMs at the same time. Anyway, more often a developer wants to test a release with his own changes before merging on the main branch. He needs to deploy his build to only his VM, without involving the others. It&amp;rsquo;s onerous for him unless he&amp;rsquo;s an Azure DevOps user, capable of modifying his deployment group, the branch where to download the artifacts, etc. It&amp;rsquo;s possible to automate all the previous steps needed to launch a release only on your target environment, starting from a particular artifact.&lt;/p>
&lt;p>In the following the steps to achive it:&lt;/p>
&lt;ol>
&lt;li>set a new tag to the VM in the DG&lt;/li>
&lt;li>put the tag into release pipeline&lt;/li>
&lt;li>launch the release pipeline&lt;/li>
&lt;li>remove the tag from DG and release pipeline&lt;/li>
&lt;/ol>
&lt;p>We have taken advantage of the &lt;a href="https://docs.microsoft.com/en-us/rest/api/azure/devops/?view=azure-devops-rest-6.1">Azure DevOps Services REST API&lt;/a> made available by Azure DevOps through a script in PowerShell.
Here there are the essential steps:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">Write-Host &lt;span style="color:#e6db74">&amp;#34;Adding tag for your VM in the Deployment Group: $deploymentGroup&amp;#34;&lt;/span>
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/distributedtask/deploymentgroups/&amp;#34;&lt;/span> + $DeploymentGroupId + &lt;span style="color:#e6db74">&amp;#34;/targets?api-version=6.0-preview.1&amp;#34;&lt;/span>
$output = Invoke-RestMethod -Uri $UriOrga -Method get -Headers $AzureDevOpsAuthenicationHeader
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/distributedtask/deploymentgroups/&amp;#34;&lt;/span> + $DeploymentGroupId + &lt;span style="color:#e6db74">&amp;#34;/targets?api-version=6.0-preview.1&amp;#34;&lt;/span>
Invoke-RestMethod -Method Patch -Uri $UriOrga -Headers $AzureDevOpsAuthenicationHeader -Body $TargetVMs -ContentType application/json
Write-Host &lt;span style="color:#e6db74">&amp;#34;Adding tag to Deployment Group stage in the Realese Pipeline&amp;#34;&lt;/span>
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://vsrm.dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/release/definitions/&amp;#34;&lt;/span> + $ReleaseDefinitionId + &lt;span style="color:#e6db74">&amp;#34;?api-version=6.0&amp;#34;&lt;/span>
$UpdateEnvironmentsBody = Invoke-RestMethod -Uri $UriOrga -Method Get -Headers $AzureDevOpsAuthenicationHeader -ContentType application/json
$UpdateEnvironmentsBody.environments[0].deployPhases[0].deploymentInput.tags = @( $Tag )
$UpdateEnvironmentsBody = ConvertTo-Json $UpdateEnvironmentsBody -Depth 10
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://vsrm.dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/release/definitions?api-version=6.0&amp;#34;&lt;/span>
Invoke-RestMethod -Uri $UriOrga -Method Put -Headers $AzureDevOpsAuthenicationHeader -Body $UpdateEnvironmentsBody -ContentType application/json
Write-Host &lt;span style="color:#e6db74">&amp;#34;Launching Release Pipeline for your VM&amp;#34;&lt;/span>
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://vsrm.dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/release/releases?api-version=6.0&amp;#34;&lt;/span>
$CreateReleaseBody = ConvertTo-Json $CreateReleaseBody -Depth 10
Invoke-RestMethod -Uri $UriOrga -Method Post -Headers $AzureDevOpsAuthenicationHeader -Body $CreateReleaseBody -ContentType application/json
Write-Host &lt;span style="color:#e6db74">&amp;#34;Removing all tags from Deployment Group stage in the Realese Pipeline&amp;#34;&lt;/span>
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://vsrm.dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/release/definitions/&amp;#34;&lt;/span> + $ReleaseDefinitionId + &lt;span style="color:#e6db74">&amp;#34;?api-version=6.0&amp;#34;&lt;/span>
$UpdateEnvironmentsBody = Invoke-RestMethod -Uri $UriOrga -Method Get -Headers $AzureDevOpsAuthenicationHeader -ContentType application/json
$UpdateEnvironmentsBody.environments[0].deployPhases[0].deploymentInput.tags = @()
$UpdateEnvironmentsBody = ConvertTo-Json $UpdateEnvironmentsBody -Depth 10
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://vsrm.dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/release/definitions?api-version=6.0&amp;#34;&lt;/span>
Invoke-RestMethod -Uri $UriOrga -Method Put -Headers $AzureDevOpsAuthenicationHeader -Body $UpdateEnvironmentsBody -ContentType application/json
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>Like any Azure service, Microsoft&amp;rsquo;s DevOps counterpart can also be managed by a set of APIs that replicate everything that can be done through the portal. First you need to get a &lt;a href="https://docs.microsoft.com/it-it/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops&amp;amp;tabs=preview-page">PAT (Personal Access Token)&lt;/a> through which you can authenticate inside your organization.
Then you can take advantage of any tool that invokes API Rest to do whatever you want, i.e. launching Release, creating or modifying Deployment Groups, starting specific Tests and so on. This can be a hint to create a user-friendly interface for developers not accustomed to DevOps. It could automate set of actions that would be otherwise onerous.&lt;/p>
&lt;p>In these cases the limit is your own imagination.&lt;/p></description></item></channel></rss>