<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bartlombardi on GetLatestVersion – Europe</title><link>http://www.getlatestversion.eu/authors/bartlombardi/</link><description>Recent content in bartlombardi on GetLatestVersion – Europe</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 03 Nov 2021 03:00:00 +0200</lastBuildDate><atom:link href="http://www.getlatestversion.eu/authors/bartlombardi/index.xml" rel="self" type="application/rss+xml"/><item><title>The limit is your own imagination, do it with Azure DevOps Services REST API</title><link>http://www.getlatestversion.eu/2021/11/the-limit-is-your-own-imagination-do-it-with-azure-devops-services-rest-api/</link><pubDate>Wed, 03 Nov 2021 03:00:00 +0200</pubDate><author>Bartolomeo Lombardi</author><author/><guid>http://www.getlatestversion.eu/2021/11/the-limit-is-your-own-imagination-do-it-with-azure-devops-services-rest-api/</guid><description>&lt;p>Azure DevOps is the platform signed by Microsoft that helps software factories to improve the development process, automatic tests and frequent releases. Their aim is to have additional value for the end customer in terms of product quality.&lt;/p>
&lt;p>With Azure DevOps Release you can separate the delivery environments into groups, obtaining integration, acceptance, production environments and so on. Most of time, the pipelines are configured to release the artifacts related to the main branches. However, Azure DevOps doesn&amp;rsquo;t allow to modify easily a specific release for a single target within a Deployment Group (DG) starting from different artifacts.&lt;/p>
&lt;h1 id="automated-through-the-azure-devops-services-rest-api">Automated through the Azure DevOps Services REST API&lt;/h1>
&lt;p>Consider a scenario in which we have a DG called &amp;ldquo;integration&amp;rdquo; that collects 20 virtual machines (VMs), one for each developer. Through this DG we can use a pipeline that deploys the latest version of the product to all the VMs at the same time. Anyway, more often a developer wants to test a release with his own changes before merging on the main branch. He needs to deploy his build to only his VM, without involving the others. It&amp;rsquo;s onerous for him unless he&amp;rsquo;s an Azure DevOps user, capable of modifying his deployment group, the branch where to download the artifacts, etc. It&amp;rsquo;s possible to automate all the previous steps needed to launch a release only on your target environment, starting from a particular artifact.&lt;/p>
&lt;p>In the following the steps to achive it:&lt;/p>
&lt;ol>
&lt;li>set a new tag to the VM in the DG&lt;/li>
&lt;li>put the tag into release pipeline&lt;/li>
&lt;li>launch the release pipeline&lt;/li>
&lt;li>remove the tag from DG and release pipeline&lt;/li>
&lt;/ol>
&lt;p>We have taken advantage of the &lt;a href="https://docs.microsoft.com/en-us/rest/api/azure/devops/?view=azure-devops-rest-6.1">Azure DevOps Services REST API&lt;/a> made available by Azure DevOps through a script in PowerShell.
Here there are the essential steps:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-powershell" data-lang="powershell">Write-Host &lt;span style="color:#e6db74">&amp;#34;Adding tag for your VM in the Deployment Group: $deploymentGroup&amp;#34;&lt;/span>
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/distributedtask/deploymentgroups/&amp;#34;&lt;/span> + $DeploymentGroupId + &lt;span style="color:#e6db74">&amp;#34;/targets?api-version=6.0-preview.1&amp;#34;&lt;/span>
$output = Invoke-RestMethod -Uri $UriOrga -Method get -Headers $AzureDevOpsAuthenicationHeader
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/distributedtask/deploymentgroups/&amp;#34;&lt;/span> + $DeploymentGroupId + &lt;span style="color:#e6db74">&amp;#34;/targets?api-version=6.0-preview.1&amp;#34;&lt;/span>
Invoke-RestMethod -Method Patch -Uri $UriOrga -Headers $AzureDevOpsAuthenicationHeader -Body $TargetVMs -ContentType application/json
Write-Host &lt;span style="color:#e6db74">&amp;#34;Adding tag to Deployment Group stage in the Realese Pipeline&amp;#34;&lt;/span>
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://vsrm.dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/release/definitions/&amp;#34;&lt;/span> + $ReleaseDefinitionId + &lt;span style="color:#e6db74">&amp;#34;?api-version=6.0&amp;#34;&lt;/span>
$UpdateEnvironmentsBody = Invoke-RestMethod -Uri $UriOrga -Method Get -Headers $AzureDevOpsAuthenicationHeader -ContentType application/json
$UpdateEnvironmentsBody.environments[0].deployPhases[0].deploymentInput.tags = @( $Tag )
$UpdateEnvironmentsBody = ConvertTo-Json $UpdateEnvironmentsBody -Depth 10
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://vsrm.dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/release/definitions?api-version=6.0&amp;#34;&lt;/span>
Invoke-RestMethod -Uri $UriOrga -Method Put -Headers $AzureDevOpsAuthenicationHeader -Body $UpdateEnvironmentsBody -ContentType application/json
Write-Host &lt;span style="color:#e6db74">&amp;#34;Launching Release Pipeline for your VM&amp;#34;&lt;/span>
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://vsrm.dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/release/releases?api-version=6.0&amp;#34;&lt;/span>
$CreateReleaseBody = ConvertTo-Json $CreateReleaseBody -Depth 10
Invoke-RestMethod -Uri $UriOrga -Method Post -Headers $AzureDevOpsAuthenicationHeader -Body $CreateReleaseBody -ContentType application/json
Write-Host &lt;span style="color:#e6db74">&amp;#34;Removing all tags from Deployment Group stage in the Realese Pipeline&amp;#34;&lt;/span>
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://vsrm.dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/release/definitions/&amp;#34;&lt;/span> + $ReleaseDefinitionId + &lt;span style="color:#e6db74">&amp;#34;?api-version=6.0&amp;#34;&lt;/span>
$UpdateEnvironmentsBody = Invoke-RestMethod -Uri $UriOrga -Method Get -Headers $AzureDevOpsAuthenicationHeader -ContentType application/json
$UpdateEnvironmentsBody.environments[0].deployPhases[0].deploymentInput.tags = @()
$UpdateEnvironmentsBody = ConvertTo-Json $UpdateEnvironmentsBody -Depth 10
$UriOrga = &lt;span style="color:#e6db74">&amp;#34;https://vsrm.dev.azure.com/&amp;lt;organization&amp;gt;/&amp;lt;project&amp;gt;/_apis/release/definitions?api-version=6.0&amp;#34;&lt;/span>
Invoke-RestMethod -Uri $UriOrga -Method Put -Headers $AzureDevOpsAuthenicationHeader -Body $UpdateEnvironmentsBody -ContentType application/json
&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>Like any Azure service, Microsoft&amp;rsquo;s DevOps counterpart can also be managed by a set of APIs that replicate everything that can be done through the portal. First you need to get a &lt;a href="https://docs.microsoft.com/it-it/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops&amp;amp;tabs=preview-page">PAT (Personal Access Token)&lt;/a> through which you can authenticate inside your organization.
Then you can take advantage of any tool that invokes API Rest to do whatever you want, i.e. launching Release, creating or modifying Deployment Groups, starting specific Tests and so on. This can be a hint to create a user-friendly interface for developers not accustomed to DevOps. It could automate set of actions that would be otherwise onerous.&lt;/p>
&lt;p>In these cases the limit is your own imagination.&lt;/p></description></item><item><title>Git Cherry-Pick for a strategic harvest</title><link>http://www.getlatestversion.eu/2020/07/git-cherry-pick-for-a-strategic-harvest/</link><pubDate>Mon, 13 Jul 2020 03:00:00 +0200</pubDate><author>Bartolomeo Lombardi</author><guid>http://www.getlatestversion.eu/2020/07/git-cherry-pick-for-a-strategic-harvest/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>IT companies which develop and sell software product are always focused on delivering new features to propose new versions of them to the final client, while still considering the maintenance of the previous release.
Generally, we are talking about projects of millions of lines of code that requires multiple developing teams located around the world with strong coordination and collaboration among them, in which it is necessary to handle multiple versions of the same product with a significant number of release branches. Fixing a bug on multiple branches is a complex task because the developer needs to backport the same fix in the various release branches possible with Git and it is called &amp;ldquo;cherry-picking&amp;rdquo;.&lt;/p>
&lt;h1 id="git-cherry-pick">Git cherry-pick&lt;/h1>
&lt;p>One of the most powerful Git commands is Cherry-pick. It takes one or more commits as input parameters and shifts them to a different branch, by creating a new commit in the process.&lt;/p>
&lt;p>Cherry-pick is commonly used in many Git workflows such as the Azure DevOps team’s, described in the following &lt;a href="https://devblogs.microsoft.com/devops/improving-azure-devops-cherry-picking/">article&lt;/a>, see the image reported below for a visual representation of the workflow.
&lt;img src="cherry-pick-workflow.jpg" alt="Cherry-Pick: way of working">&lt;/p>
&lt;p>Every time a developer works with many version of the same product it is essential to ensure all the reported bugs have been fixed in as many version as possible. Cherry-picking happens on the main branch to avoid deploying a new release with the same bug.&lt;/p>
&lt;h2 id="azure-devops-repos">Azure DevOps Repos&lt;/h2>
&lt;p>Azure DevOps provides cherry-picking of a completed Pull Request (PR) or of a single commit by clicking a dedicated button. The process will create a new PR with the same fix.
&lt;img src="azdo-cp.jpg" alt="Cherry-Pick Azure DevOps">&lt;/p>
&lt;p>Moreover, a &lt;a href="https://github.com/microsoft/azure-repos-pr-multi-cherry-pick">PR Multi-Cherry-Pick&lt;/a> is possible by means of an open source extension available on Azure DevOps Marketplace.&lt;/p>
&lt;p>If Azure DevOps displays a warning about the cherry-picking not being performed automatically (see image below) this is related to conflicts generated during the merge, therefore it has to be performed locally.
&lt;img src="azdo-cp-error.jpg" alt="Azure DevOps conflict errors">&lt;/p>
&lt;p>Many development environments integrated with Git can perform this local operation by graphic user interface. Best candidates are Visual Studio or VS Code.&lt;/p>
&lt;h1 id="git-cherry-pick---continue">Git cherry-pick &amp;ndash;continue&lt;/h1>
&lt;p>A few steps are needed to execute the following command &lt;a href="https://git-scm.com/docs/git-cherry-pick">git cherry-pick&lt;/a>.&lt;/p>
&lt;p>The first step is noting of the hash commit value to cherry-pick. If within a PR, the list of commits is available in the &lt;strong>Commits&lt;/strong> tab in Azure Repos:
&lt;img src="azdo-commits-tab.jpg" alt="Commit table on Azure DevOps">&lt;/p>
&lt;p>Once you are on the branch (&lt;code>git checkout &amp;lt;branch-name&amp;gt;&lt;/code>) that you want to commit, the following command must be executed &lt;code>git cherry-pick &amp;lt;commit&amp;gt;&lt;/code>.&lt;/p>
&lt;p>Knowing that the cherry-pick command shown in the previous example can generate another conflict, once the code is merged manually you need to run the &lt;code>git cherry-pick --continue&lt;/code> to proceed. If you want to abort the process simply run git &lt;code>cherry-pick --abort&lt;/code>.&lt;/p>
&lt;p>All you need to do now is to perform &lt;code>git push&lt;/code> to align the remote.&lt;/p></description></item><item><title>Code dependencies: Binary Composition is not only a mathematics calculation</title><link>http://www.getlatestversion.eu/2020/05/code-dependencies-binary-composition-is-not-only-a-mathematics-calculation/</link><pubDate>Sun, 17 May 2020 16:00:00 +0200</pubDate><author>Bartolomeo Lombardi</author><guid>http://www.getlatestversion.eu/2020/05/code-dependencies-binary-composition-is-not-only-a-mathematics-calculation/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>Over the years, the growing code base of application software with multiple teams working on the same product, has lead to break up the solution into multiple solutions. This has been done trying to reduce the time required for the build and for their integration, to ease Integrated Development Environment in opening hundreds of projects, and other.
The main consequence of having multiple solutions is binary composition.&lt;/p>
&lt;h1 id="what-is-binary-composition">What is binary composition?&lt;/h1>
&lt;p>Binary composition occurs when one or more solutions reference the compiled binaries of another solution. Let suppose it is needed to make the binaries of Solution B available to Solution A before Solution A can build successfully.&lt;/p>
&lt;p>&lt;img src="visual-studio-references.jpg" alt="image.png">&lt;/p>
&lt;p>If you are forced to commit the code together with the binaries produced by build in the repository&amp;hellip;Keep on reading :)&lt;/p>
&lt;h1 id="how-can-we-distribute-binaries">How can we distribute binaries?&lt;/h1>
&lt;p>We can make those binaries available in several ways.&lt;/p>
&lt;h2 id="git-repository">Git repository&lt;/h2>
&lt;p>A first possibility consists in committing them into a repository anytime a merge into the development/master branch by means of the Continuous Integration build pipeline is requested by a Pull Request. Of course, this increases the size of the repository introducing significant slowdown checkout times and performances. Imagine what could happen if teams work on different branches ending up using different versions of the same binaries creating merge conflicts.&lt;/p>
&lt;h2 id="file-share">File share&lt;/h2>
&lt;p>Another option consists in putting the binaries onto a file share. In this case, however, there is no index to find binaries quickly and there is no protection against overriding a version.&lt;/p>
&lt;h2 id="package-management-with-azure-artifacts">Package Management with Azure Artifacts&lt;/h2>
&lt;p>This should definitely be the most suitable solution because it allows putting binaries into NuGet (and other as npm, Maven, Python, and universal) packages making it possible for Solution A to reference these packages. Among the several advantages introduced by this methodology, in Continuous Integration Azure pipeline a NuGet published task can be added in order to make the update versioning procedure automatic and distributing it in a reliable way also.&lt;/p></description></item></channel></rss>