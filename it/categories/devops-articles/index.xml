<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>devops articles on GetLatestVersion – Italia</title><link>http://www.getlatestversion.eu/it/categories/devops-articles/</link><description>Recent content in devops articles on GetLatestVersion – Italia</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 13 Jul 2020 03:00:00 +0200</lastBuildDate><atom:link href="http://www.getlatestversion.eu/it/categories/devops-articles/index.xml" rel="self" type="application/rss+xml"/><item><title>Git Cherry-Pick per un raccolto strategico</title><link>http://www.getlatestversion.eu/it/2020/07/git-cherry-pick-per-un-raccolto-strategico/</link><pubDate>Mon, 13 Jul 2020 03:00:00 +0200</pubDate><author>Bartolomeo Lombardi</author><guid>http://www.getlatestversion.eu/it/2020/07/git-cherry-pick-per-un-raccolto-strategico/</guid><description>&lt;h1 id="introduzione">Introduzione&lt;/h1>
&lt;p>Le aziende IT che sviluppano e vendono un prodotto software sono sempre più concentrate sui rilasci di nuove funzionalità per proporre nuove versioni, senza tralasciare la manutenzione delle precedenti, utilizzate dai clienti.
Generalemente si parla di progetti di milioni di righe di codice che prevedono più team di svilupattori siti in tutto il globo con una forte coordinazione e collaborazione tra loro, in cui si trovano a dover maneggiare più versioni dello stesso prodotto con un numero significativo di rami di release.
Fissare un bug su più versioni è un compito oneroso poichè lo sviluppatore deve riportare le stesse correzioni nei vari rami di release. Quest&amp;rsquo;ultima azione in Git è possibile ed è detta &amp;ldquo;cherry picking&amp;rdquo;.&lt;/p>
&lt;h1 id="git-cherry-pick">Git cherry-pick&lt;/h1>
&lt;p>Uno tra i più potenti comandi che git mette a disposizione è il cherry-pick. Questo comando prende in input uno o più commmit e applica gli stessi cambiamenti su un ramo differente, attraverso la creazione di un nuovo commit. Infatti, la &amp;ldquo;raccolta di ciliegie&amp;rdquo;, letteralmente, è l&amp;rsquo;atto di scegliere un commit da un ramo e applicarlo su un altro.&lt;/p>
&lt;p>Il cherry-pick è un comando estremamente efficace in molti flussi di lavoro basati su Git come ad esempio quello usato dal team di &lt;a href="https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow">Azure DevOps&lt;/a> come descritto nel seguente &lt;a href="https://devblogs.microsoft.com/devops/improving-azure-devops-cherry-picking/">articolo&lt;/a>, di cui riporto un&amp;rsquo;immagine che rappresenta il sopracitato flusso di lavoro.
&lt;img src="cherry-pick-workflow.jpg" alt="Cherry-Pick: flusso di rilascio">&lt;/p>
&lt;p>Quando si lavora con più versioni dello stesso prodotto è indispensabile assicurarsi che tutti i bug segnalati siano correttamente risolti e che tutte le versioni in vita del prodotto siano conseguentemente aggiornate; tale azione viene effettuata anche sul ramo main al fine di evitare di creare una nuova release con lo stesso bug.&lt;/p>
&lt;h2 id="azure-devops-repos">Azure DevOps Repos&lt;/h2>
&lt;p>Azure DevOps mette a disposizione il comando cherry-pick di una Pull Request (PR) completata o del singolo commit, direttamente dalla piattaforma. Tale meccanismo crea una nuova PR con i medesimi cambiamenti sul ramo su cui si necessita della fix.
&lt;img src="azdo-cp.jpg" alt="Cherry-Pick di una PR da Azure DevOps">&lt;/p>
&lt;p>Inoltre, è possibile effettuare un cherry-pick multiplo con pochi click, grazie ad un&amp;rsquo;estensione open source scaricabile ed installabile attraverso il marketplace di Azure DevOps &lt;a href="https://github.com/microsoft/azure-repos-pr-multi-cherry-pick">PR Multi-Cherry-Pick&lt;/a>.&lt;/p>
&lt;p>Molte volte è possibile ritrovarsi nella medesima situazione dell&amp;rsquo;immagine sottostante in cui Azure DevOps avverte che non è possibile effettuare il cherry-pick del commit automaticamente in quanto la modifica che si sta implementando genera conflitti e va, pertanto, effettuata in locale.
&lt;img src="azdo-cp-error.jpg" alt="Errore durante Cherry-Pick in Azure DevOps">&lt;/p>
&lt;p>Ci sono molti ambienti di sviluppo che si integrano con Git e permettono di effettuare tale operazione attraverso un&amp;rsquo;interfaccia grafica. Per esempio Visual Studio o VSCode sono degli ottimi candidati.&lt;/p>
&lt;h2 id="git-cherry-pick---continue">Git cherry-pick &amp;ndash;continue&lt;/h2>
&lt;p>Sono necessari pochi passi per effettuare il procedimento di &lt;a href="https://git-scm.com/docs/git-cherry-pick">git cherry-pick&lt;/a> da riga di comando.&lt;/p>
&lt;p>La prima azione e&amp;rsquo; prendere nota dell&amp;rsquo;hash dei commits di cui si intende effettuare l&amp;rsquo;azione di cherry-pick; nel caso specifico di una PR l&amp;rsquo;elenco dei commit e&amp;rsquo; consultabile nella tab &lt;strong>Commits&lt;/strong> in Azure DevOps Repos, come mostrato nell&amp;rsquo;immagine seguente.
&lt;img src="azdo-commits-tab.jpg" alt="Tabella dei commit di una PR in Azure DevOps">&lt;/p>
&lt;p>Spostandosi sul branch (&lt;code>git checkout &amp;lt;nome-branch&amp;gt;&lt;/code>) in cui si intende portare il commit si deve eseguire il comando &lt;code>git cherry-pick &amp;lt;commit&amp;gt;&lt;/code>.
Siamo a conoscenza che il cherry-pick di questo commit causa conflitto, quindi una volta effettuto il merge manuale con Visual Studio (o altri IDE) va poi lanciato &lt;code>git cherry-pick --continue&lt;/code> per procedere con l&amp;rsquo;operazione; se invece si vuole terminare il procedimento basta digitare &lt;code>git cherry-pick --abort&lt;/code>.&lt;/p>
&lt;p>Una volta completato il processo va effettuato un &lt;code>git push&lt;/code> del nuovo commit generato.&lt;/p></description></item><item><title>SQL Wars - L'attacco dei cloni e la ribellione dei container</title><link>http://www.getlatestversion.eu/it/2020/05/sql-wars-lattacco-dei-cloni-e-la-ribellione-dei-container/</link><pubDate>Mon, 18 May 2020 11:30:00 +0200</pubDate><author>Alessandro Alpi</author><guid>http://www.getlatestversion.eu/it/2020/05/sql-wars-lattacco-dei-cloni-e-la-ribellione-dei-container/</guid><description>&lt;p>Getlatestversion ha partecipato a &lt;a href="https://cloudgen.it/home-gen-events/">HomeGen&lt;/a>, una bellissima iniziativa dei nostri amici di &lt;a href="https://cloudgen.it/">CloudGen Verona&lt;/a>.&lt;/p>
&lt;p>&lt;a href="https://www.getlatestversion.eu/it/authors/suxstellino/">Alessandro Alpi&lt;/a> e &lt;a href="https://www.getlatestversion.eu/it/authors/giulianolatini/">Giuliano Latini&lt;/a> hanno presentato &amp;ldquo;SQL Wars, l&amp;rsquo;attacco dei cloni e la ribellione dei container&amp;rdquo;, una sessione su come fare provisioning dei dati di produzioni in ambienti diversi tramite qualche click o in automation.&lt;/p>
&lt;p>&lt;img src="sql-clone-container-title.png" alt="image.png">&lt;/p>
&lt;p>La registrazione della sessione è disponibile nel video seguente sul nostro &lt;a href="https://www.youtube.com/c/getlatestversion">canale YouTube&lt;/a>.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/5qSJa0Zxd-g" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div></description></item><item><title>Code dependencies: La Binary Composition non è solo un artefatto algebrico</title><link>http://www.getlatestversion.eu/it/2020/05/code-dependencies-la-binary-composition-non-%C3%A8-solo-un-artefatto-algebrico/</link><pubDate>Sun, 17 May 2020 16:00:00 +0200</pubDate><author>Bartolomeo Lombardi</author><guid>http://www.getlatestversion.eu/it/2020/05/code-dependencies-la-binary-composition-non-%C3%A8-solo-un-artefatto-algebrico/</guid><description>&lt;h1 id="introduzione">Introduzione&lt;/h1>
&lt;p>Nel corso degli anni, l&amp;rsquo;aumento delle righe di codice sorgente dei software, con più team che lavorano sullo stesso prodotto, ha portato alla suddivisione di una unica soluzione in più soluzioni. Molteplici sono le motivazioni che hanno spinto verso questo cambiamento; le principali sono la riduzione del tempo necessario per la compilazione, la riduzione del tempo impiegato per l&amp;rsquo;integrazione delle soluzioni nonchè l&amp;rsquo;ottimizzazione dei tempi di avvio dell&amp;rsquo;ambiente di sviluppo popolato da centinaia di progetti.
La binary composition è la principale conseguenza dello spacchettamento della soluzione.&lt;/p>
&lt;h1 id="cosè-la-binary-composition">Cos'è la binary composition?&lt;/h1>
&lt;p>Si parla di binary composition quando una o più soluzioni fanno riferimento a file binari prodotti da altre soluzioni. Nell&amp;rsquo;immagine seguente, sono rappresentate a scopo esemplificativo due soluzioni Visual Studio: soluzione A e soluzione B. La soluzione B contiene dei componenti ai quali la soluzione A si riferisce. E&amp;rsquo; quindi necessario che i file binari prodotti dalla soluzione B siano disponibili prima che la soluzione A possa essere compilata.&lt;/p>
&lt;p>&lt;img src="visual-studio-references.jpg" alt="image.png">&lt;/p>
&lt;h1 id="come-possiamo-distribuire-i-file-binari">Come possiamo distribuire i file binari?&lt;/h1>
&lt;p>Ci sono diversi modi in cui possiamo rendere disponibili i file binari.&lt;/p>
&lt;h2 id="repository-git">Repository Git&lt;/h2>
&lt;p>Una delle possibilità è fare commit dei file binari nel repository ogni qualvolta che lo sviluppatore richiede di fare merge con le sue modifiche nel ramo development/master - attraverso una Pull Request. Il tutto può essere realizzato mediante un processo automatico che si traduce in una pipeline di Continuous Integration. Naturalmente, questo comporterebbe l&amp;rsquo;aumento delle dimensioni del repository, introducendo tempi significativi di checkout e di prestazioni.
Immaginiamo cosa potrebbe accadere se i team lavorassero su rami diversi ritrovandosi ad utilizzare differenti versioni degli stessi file binari: si creerebbero sicuramente conflitti durante la fase di merge.&lt;/p>
&lt;h2 id="condivisione-in-cartella-di-rete">Condivisione in cartella di rete&lt;/h2>
&lt;p>Un&amp;rsquo;altra opzione consiste nel caricare i file binari in una cartella di rete condivisa. Adottando questa soluzione non sarà però disponibile l&amp;rsquo;indicizzazione per facilitare la ricerca rapida dei file binari e inoltre non esisterà alcuna protezione contro l&amp;rsquo;override di una specifica versione.&lt;/p>
&lt;h2 id="gestione-dei-pacchetti-mediante-lutilizzo-di-azure-artifact">Gestione dei pacchetti mediante l&amp;rsquo;utilizzo di Azure Artifact&lt;/h2>
&lt;p>Questa rappresenta sicuramente la soluzione più adatta, poichè consente di inserire i file binari in pacchetti NuGet (e altri come npm, Maven, Python e Universal). In questo modo i progetti contenuti nella soluzione A possono fare riferimento a tali pacchetti.
Uno dei vantaggi introdotti da questa metodologia è la possibilità di aggiungere un task di pubblicazione NuGet nella pipeline di Continuous Integration di Azure DevOps, che automatizzi la procedura di versionamento del pacchetto e che renda la procedura di distribuzione più affidabile.&lt;/p></description></item></channel></rss>